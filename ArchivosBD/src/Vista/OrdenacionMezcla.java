/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Vista;

import Control.AccesoAleatorio;
import Modelo.Libro;
import Modelo.LimitarCaracter;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.swing.JOptionPane;

/**
 *
 * @author usurio
 */
public class OrdenacionMezcla extends javax.swing.JFrame {

    /**
     * Creates new form OrdenacionMezcla
     */
    static int T;
    static String Men;
    public OrdenacionMezcla() {
        initComponents();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        tbFactorBloqueo = new javax.swing.JTextField();
        tbMarcos = new javax.swing.JTextField();
        btnMezcla = new javax.swing.JButton();
        btnOrdenarTitulo = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        taSalida = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jLabel1.setText("Número de registros por bloque:");

        jLabel2.setText("Número de marcos de memoria intermedia:");

        btnMezcla.setText("Ordenar por Codigo");
        btnMezcla.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMezclaActionPerformed(evt);
            }
        });

        btnOrdenarTitulo.setText("Ordenar por Titulo");
        btnOrdenarTitulo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOrdenarTituloActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(83, 83, 83)
                                .addComponent(tbFactorBloqueo, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(18, 18, 18)
                                .addComponent(tbMarcos))))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(84, 84, 84)
                        .addComponent(btnMezcla)
                        .addGap(37, 37, 37)
                        .addComponent(btnOrdenarTitulo)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(tbFactorBloqueo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(tbMarcos, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnMezcla)
                    .addComponent(btnOrdenarTitulo))
                .addContainerGap(28, Short.MAX_VALUE))
        );

        taSalida.setColumns(20);
        taSalida.setRows(5);
        jScrollPane1.setViewportView(taSalida);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 613, Short.MAX_VALUE)
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 606, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    public static boolean RegistroACambiar(int []Comparador)
    {
        
        boolean Salida=false;
        for(int i = 0;i < Comparador.length; i++)
        {
            if(Comparador[i]==-1)
            {
                Salida=true;
            }
            
        }
        return Salida;
    }
    public static int ObtenerRegistroACambiar(int []Comparador)
    {
        int inicial=1;
        for(int i = 0;i < Comparador.length; i++)
        {
            if(Comparador[i]==-1)
            {
                inicial=i;
            }
        }
        return inicial;
    }
    public static void ArregloVerdadero(boolean []arreglo,int []Comparador,int FactorBloqueo)//devuelve un los falsos
    { 
        int i=0;
        int salida=-1;
        
         while(FactorBloqueo*i<arreglo.length)
        {
            salida=-1;
             for(int j=FactorBloqueo*i;j < FactorBloqueo*(i+1); j++)
             {
                 if(arreglo[j]==false)
                 {
                     salida=(FactorBloqueo-(FactorBloqueo-1));
                 }
                 
             }
             Comparador[i]=salida;
             i=i+1;
        }   
    }
    public  static String [] Burbuja( String [] arreglo)
    {
        for(int i = 0; i < arreglo.length - 1; i++)
        {
            for(int j = 0; j < arreglo.length -1; j++)
            {
                
                int Valor=arreglo[j].compareTo(arreglo[j + 1]);
                if (Valor>=0)//arreglo[j] > arreglo[j + 1]
                {
                    String tmp = arreglo[j+1];
                    arreglo[j+1] = arreglo[j];
                    arreglo[j] = tmp;
                    
                }
                //Mostrar(arreglo);
            }
        }
    return arreglo;
    }
    public  static String [] BurbujaT( String [] arreglo)//ordena por titulos
    {
        for(int i = 0; i < arreglo.length - 1; i++)
        {
            for(int j = 0; j < arreglo.length -1; j++)
            {
                
                int Valor=(arreglo[j].substring(5,55)).compareTo((arreglo[j+1].substring(5,55)));
                if (Valor>=0)//arreglo[j] > arreglo[j + 1]
                {
                    String tmp = arreglo[j+1];
                    arreglo[j+1] = arreglo[j];
                    arreglo[j] = tmp;
                    
                }
                //Mostrar(arreglo);
            }
        }
    return arreglo;
    }
    public  static ArrayList<String>  Burbuja1( ArrayList<String>  arreglo)
    {
        for(int i = 0; i < arreglo.size() - 1; i++)
        {
            for(int j = 0; j < arreglo.size() -1; j++)
            {
                
                int Valor=arreglo.get(j).compareTo(arreglo.get(j+1));
                if (Valor>=0)//arreglo[j] > arreglo[j + 1]
                {
                    String tmp = arreglo.get(j+1);
                    arreglo.set(j+1, arreglo.get(j));
                    arreglo.set(j, tmp);
                    
                    
                    
                }
                //Mostrar(arreglo);
            }
        }
    return arreglo;
    }
    public static int Minimo(String []arreglo)
    {
        int PosMenor = 0;
        String Menor=arreglo[0];
        for(int i = 0;i < arreglo.length; i++)
        {
                     
            if(arreglo[i].compareTo(Menor)<=0)
            {
                Menor = arreglo[i];
                PosMenor = i;
                
            }
        }
        return PosMenor;
    }
    public static int MinimoT(String []arreglo)
    {
        int PosMenor = 0;
        String Menor=arreglo[0].substring(5,55);
        for(int i = 0;i < arreglo.length; i++)
        {
                     
            if(arreglo[i].substring(5,55).compareTo(Menor)<=0)
            {
                Menor = arreglo[i];
                PosMenor = i;
                
            }
        }
        return PosMenor;
    }
    public static void CambiarValorTrue(boolean []arreglo,int Pos)
    {
        for(int i = 0;i < arreglo.length; i++)
        {
            if(Pos==i)
            {
                arreglo[i]=true;
            }
        }
        
    }
    public static void Actualizar(int []Comparador)//reinicia a cero para validar
    {
        for(int i = 0;i < Comparador.length; i++)
        {
            Comparador[i]=0;
        }
    }
    private void btnMezclaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMezclaActionPerformed
        // TODO add your handling code here:
        String _FactorBloqueo = tbFactorBloqueo.getText();
        if(_FactorBloqueo.isEmpty()) {//verificacion si esta vacio
            JOptionPane.showMessageDialog(this, "¡No se ingreso el Número de registros por bloque!", "Advertencia", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        
        int FactorBloqueo=Integer.parseInt(_FactorBloqueo);
        String _Marcos = tbMarcos.getText();
        if(_Marcos.isEmpty()) {//verificacion si esta vacio
            JOptionPane.showMessageDialog(this, "¡No se ingreso el Número de marcos en memoria intermedia!", "Advertencia", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        int Marcos=Integer.parseInt(_Marcos);
        //VALIDACION
        try {
            AccesoAleatorio.crearFileLibro(new File("ArchivosCreados\\Libro.dat"));
            int Tam = AccesoAleatorio.getNumeroRegistros();
            int Nro=(Tam-1)/(FactorBloqueo*Marcos);
            if(((Tam-1)%(FactorBloqueo*Marcos))!=0)
            {
                Nro=Nro+1;
                
            }
            if(Marcos<Nro){
                JOptionPane.showMessageDialog(this, "¡Se crearian "+Nro+" ordenaciones! que son mayores al numero de Marcos", "Advertencia", JOptionPane.WARNING_MESSAGE);
                return;
            }
            AccesoAleatorio.cerrar();
            //JOptionPane.showMessageDialog(this, "El registro se realizó correctamente.", "Notificación", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, "Error en la escritura de datos.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        
        
        StringBuilder Salida = new StringBuilder();
        int NroRegistros;
        String[] MemoIntermedia=new String[FactorBloqueo*Marcos];//tamaño de la memoria intermedia
        
        //REGION PRIMERA ETAPA ORDENACION
        try {
            AccesoAleatorio Libros=new AccesoAleatorio();
            Libros.crearFileLibro( new File("ArchivosCreados\\Libro.dat"));
            NroRegistros = Libros.getNumeroRegistros();//obtener tamamo del archivo
            Libros.cerrar();
           
            //Salida.append(NroRegistros+"\n");
            int L=1;
            for(int i = 1;i <= (NroRegistros-1)/(FactorBloqueo*Marcos); i++)//recorrido para cada secuencia de ordenacion -1 por que hay u registro extra vacio
            {
                 AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\Libro.dat") );
                    
                 
                 for(int j = 0;j < MemoIntermedia.length; j++)//agregar libros a memoria intermedia
                 {
                     Libro A=AccesoAleatorio.getLibro(L);
                     MemoIntermedia[j]=A.Atributos();
                     L=L+1;
                 }
                 AccesoAleatorio.cerrar();
                 Burbuja(MemoIntermedia);//ordenamiento por burbuja
                 Salida.append("\n");
                 Salida.append("ITERACION DE ORDENACION SOC_"+i+"\n");//titulo de cada archivo de ordenacion para mostrar en la caja de texto
                 taSalida.setText(Salida.toString());
                 //AccesoAleatorio Ordenacion=new AccesoAleatorio();
                 
                 for(int k = 0;k < MemoIntermedia.length; k++)
                 {
                    Salida.append(MemoIntermedia[k]+"\n");
                 }
                 taSalida.setText(Salida.toString());
                 try {
                    AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\SOC_"+i+".dat") );//creacion de archivo.dat
                    for(int k = 0;k < MemoIntermedia.length; k++)
                    {
                        String CodLibro=MemoIntermedia[k].substring(0,5);//cortamos cada atributo del registro
                        String Titulo=MemoIntermedia[k].substring(5,55);
                        String Autor=MemoIntermedia[k].substring(55,85);
                        int Año=Integer.parseInt(MemoIntermedia[k].substring(85,89));//conversion a int del año
                        int Estado=Integer.parseInt(MemoIntermedia[k].substring(89,90));
                       AccesoAleatorio.añadirLibro(new Libro(CodLibro,Titulo,Autor,Año,Estado));
                    }
                    AccesoAleatorio.cerrar();
      
                } catch (IOException ex) {
                    JOptionPane.showMessageDialog(this, "Error en insercion de datos a registros.", "Error", JOptionPane.ERROR_MESSAGE);
                }
                 
                 T=i;
            }
            
            if((NroRegistros-1)%(FactorBloqueo*Marcos)!=0)//proceso para la parte sobrante de registro que solo sera una ves ejm 100%8=4 registros sobrantes a tratar
            {
                 String[] Memoria=new String[(NroRegistros-1)%(FactorBloqueo*Marcos)];
                  AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\Libro.dat") );
                    
                 
                 for(int j = 0;j < Memoria.length; j++)//agregar libros a memoria intermedia
                 {
                     Libro A=Libros.getLibro(L);
                     Memoria[j]=A.Atributos();
                     L=L+1;
                 }
                 AccesoAleatorio.cerrar();
                 Burbuja(Memoria);//ordenamiento por burbuja
                 Salida.append("\n");
                 Salida.append("ITERACION DE ORDENACION SOC_"+(T+1)+"\n");//titulo de cada archivo de ordenacion para mostrar en la caja de texto
                 for(int k = 0;k < Memoria.length; k++)
                 {
                    Salida.append(Memoria[k]+"\n");
                 }
                 taSalida.setText(Salida.toString());
                 
                 try {
                    AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\SOC_"+(T+1)+".dat") );//creacion de archivo.dat
                    for(int k = 0;k < Memoria.length; k++)
                    {
                        String CodLibro=Memoria[k].substring(0,5);//cortamos cada atributo del registro
                        String Titulo=Memoria[k].substring(5,55);
                        String Autor=Memoria[k].substring(55,85);
                        int Año=Integer.parseInt(Memoria[k].substring(85,89));//conversion a int del año
                        int Estado=Integer.parseInt(Memoria[k].substring(89,90));
                       AccesoAleatorio.añadirLibro(new Libro(CodLibro,Titulo,Autor,Año,Estado));
                    }
                    AccesoAleatorio.cerrar();
      
                } catch (IOException ex) {
                    JOptionPane.showMessageDialog(this, "Error en insercion de datos a registros.", "Error", JOptionPane.ERROR_MESSAGE);
                }
                T=T+1;
            }
            String[] Mem=new String[NroRegistros];
            Men=LimitarCaracter.Parametro(Mem);
            JOptionPane.showMessageDialog(this, "El registro se realizó correctamente.", "Notificación", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, "Error en la escritura de datos.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        //FINAL PRIMERA ETAPA ORDENACION
        //SEGUNDA ETAPA ORDENACION SI N<=M
        try {
            AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\Libro.dat"));
            NroRegistros = AccesoAleatorio.getNumeroRegistros();
            AccesoAleatorio.cerrar();
            String[] MemoriaI=new String[FactorBloqueo*T];//T=N
        Salida.append("\n");
        Salida.append("SMC_FINAL\n");
        int mem=0;
        for(int i = 0;i < T; i++)//4//llenado inicial de datos a la memoriaI 
        {
            
            try {
            AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\SOC_"+(i+1)+".dat") );
            for(int j = 0;j < FactorBloqueo; j++)//3
            {   
                Libro A=AccesoAleatorio.getLibro(j);
                MemoriaI[mem]=A.Atributos();
                //Salida.append(A.Atributos()+"gaaaaaa \n");   
                mem=mem+1;
            }
             AccesoAleatorio.cerrar();
            } catch (IOException ex) {
              JOptionPane.showMessageDialog(this, "Error en insercion de datos a registros.", "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
       
        
        
        
     
        boolean Indice[] =new boolean[FactorBloqueo*T];//arreglo de indices para marcado
        
        for(int i = 0;i < Indice.length; i++)//inicializacion en falsos
        {
            Indice[i]=false;
        }
        int Acumuladores[] =new int[T];//guardan valores de inicio dinamoco de los valores donde comenzaran las lecturas de cada registro
        for(int i = 0;i < Acumuladores.length; i++)
        {
            Acumuladores[i]=FactorBloqueo;
        }
        int comparador[] =new int[T];//arreglo de indices para marcado el q tenga -1 se debe agregar otros balores
        int ContadorRegistros=FactorBloqueo*T;
        Salida.append(Men);
        while(ContadorRegistros<=NroRegistros-1){
        Actualizar(comparador);
        int pos = Minimo(MemoriaI);//obtengo la posicion de valor minimo
        AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\SMC_Final.dat") );//escribir en el archivo el registro
        String CodLibro=MemoriaI[pos].substring(0,5);//cortamos cada atributo del registro
        String Titulo=MemoriaI[pos].substring(5,55);
        String Autor=MemoriaI[pos].substring(55,85);
        int Año=Integer.parseInt(MemoriaI[pos].substring(85,89));//conversion a int del año
        int Estado=Integer.parseInt(MemoriaI[pos].substring(89,90));
        AccesoAleatorio.añadirLibro(new Libro(CodLibro,Titulo,Autor,Año,Estado));
        AccesoAleatorio.cerrar();
        
        MemoriaI[pos]="~~~~~~~~~~~";//cambiamos el valor de ese registro al mayoe posible
        
        CambiarValorTrue(Indice,pos);//cambio el valor de esa posicion a true para decir k esta vacia
        
        ArregloVerdadero(Indice,comparador,FactorBloqueo);//obtengo mi arreglo donde la posicion -1 sera el valor inicial a cambiar y ese valor*factro de bloque el final
         
        if(RegistroACambiar(comparador)==true)
        {
        int H=ObtenerRegistroACambiar(comparador);//verifico si existe algun bloque a cambiar
        AccesoAleatorio.crearFileLibro(new File("ArchivosCreados\\SOC_"+(H+1)+".dat"));//coloco los registros correspandientes en memoriaintermedia
        
        int valor=Acumuladores[H];//valor incial para extraer un registro del alrchivo
        int valor1=H*FactorBloqueo;//posicion de incio para agregar a la memoria intermedia
        for(int k = valor1;k < valor1+FactorBloqueo; k++)//inicializacion en falsos
        {
            
            Libro A=AccesoAleatorio.getLibro(valor);
            MemoriaI[k]=A.Atributos();
            valor=valor+1;
        }                         
        AccesoAleatorio.cerrar();
        Acumuladores[H]=Acumuladores[H]+FactorBloqueo;//actualizo aumentando el valor de inicio de registro del q se saco valores
        
        }
        taSalida.setText(Salida.toString());
        ContadorRegistros=ContadorRegistros+1;
        }
        taSalida.setText(Salida.toString());
        JOptionPane.showMessageDialog(this, "El registro se realizó correctamente.", "Notificación", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException ex) {
            //JOptionPane.showMessageDialog(this, "Error en la escritura de datos.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        //FINAL DEGUNSA ETAPA
        
        
        
         
        
        taSalida.setText(Salida.toString());
        
        
        
   
    }//GEN-LAST:event_btnMezclaActionPerformed

    private void btnOrdenarTituloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOrdenarTituloActionPerformed
        // TODO add your handling code here:
        String _FactorBloqueo = tbFactorBloqueo.getText();
        if(_FactorBloqueo.isEmpty()) {//verificacion si esta vacio
            JOptionPane.showMessageDialog(this, "¡No se ingreso el Número de registros por bloque!", "Advertencia", JOptionPane.WARNING_MESSAGE);
            return;
        } 
        int FactorBloqueo=Integer.parseInt(_FactorBloqueo);
        String _Marcos = tbMarcos.getText();
        if(_Marcos.isEmpty()) {//verificacion si esta vacio
            JOptionPane.showMessageDialog(this, "¡No se ingreso el Número de marcos en memoria intermedia!", "Advertencia", JOptionPane.WARNING_MESSAGE);
            return;
        }
        int Marcos=Integer.parseInt(_Marcos);
        //VALIDACION
        try {
            AccesoAleatorio.crearFileLibro(new File("ArchivosCreados\\Libro.dat"));
            int Tam = AccesoAleatorio.getNumeroRegistros();
            int Nro=(Tam-1)/(FactorBloqueo*Marcos);
            if(((Tam-1)%(FactorBloqueo*Marcos))!=0)
            {
                Nro=Nro+1;
                
            }
            if(Marcos<Nro){
                JOptionPane.showMessageDialog(this, "¡Se crearian "+Nro+" ordenaciones! que son mayores al numero de Marcos", "Advertencia", JOptionPane.WARNING_MESSAGE);
                return;
            }
            AccesoAleatorio.cerrar();
            //JOptionPane.showMessageDialog(this, "El registro se realizó correctamente.", "Notificación", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, "Error en la escritura de datos.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        
        StringBuilder Salida = new StringBuilder();
        int NroRegistros;
        String[] MemoIntermedia=new String[FactorBloqueo*Marcos];//tamaño de la memoria intermedia
        
        //REGION PRIMERA ETAPA ORDENACION
        try {
            AccesoAleatorio Libros=new AccesoAleatorio();
            Libros.crearFileLibro( new File("ArchivosCreados\\Libro.dat"));
            NroRegistros = Libros.getNumeroRegistros();//obtener tamamo del archivo
            Libros.cerrar();
           
            //Salida.append(NroRegistros+"\n");
            int L=1;
            for(int i = 1;i <= (NroRegistros-1)/(FactorBloqueo*Marcos); i++)//recorrido para cada secuencia de ordenacion
            {
                 AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\Libro.dat") );
                    
                 
                 for(int j = 0;j < MemoIntermedia.length; j++)//agregar libros a memoria intermedia
                 {
                     Libro A=AccesoAleatorio.getLibro(L);
                     MemoIntermedia[j]=A.Atributos();
                     L=L+1;
                 }
                 AccesoAleatorio.cerrar();
                 BurbujaT(MemoIntermedia);//ordenamiento por burbuja
                 Salida.append("\n");
                 Salida.append("ITERACION DE ORDENACION SOT_"+i+"\n");//titulo de cada archivo de ordenacion para mostrar en la caja de texto
                 taSalida.setText(Salida.toString());
                 //AccesoAleatorio Ordenacion=new AccesoAleatorio();
                 
                 for(int k = 0;k < MemoIntermedia.length; k++)
                 {
                    Salida.append(MemoIntermedia[k]+"\n");
                 }
                 taSalida.setText(Salida.toString());
                 try {
                    AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\SOT_"+i+".dat") );//creacion de archivo.dat
                    for(int k = 0;k < MemoIntermedia.length; k++)
                    {
                        String CodLibro=MemoIntermedia[k].substring(0,5);//cortamos cada atributo del registro
                        String Titulo=MemoIntermedia[k].substring(5,55);
                        String Autor=MemoIntermedia[k].substring(55,85);
                        int Año=Integer.parseInt(MemoIntermedia[k].substring(85,89));//conversion a int del año
                        int Estado=Integer.parseInt(MemoIntermedia[k].substring(89,90));
                       AccesoAleatorio.añadirLibro(new Libro(CodLibro,Titulo,Autor,Año,Estado));
                    }
                    AccesoAleatorio.cerrar();
      
                } catch (IOException ex) {
                    JOptionPane.showMessageDialog(this, "Error en insercion de datos a registros.", "Error", JOptionPane.ERROR_MESSAGE);
                }
                 
                 T=i;
            }
            
            if((NroRegistros-1)%(FactorBloqueo*Marcos)!=0)//proceso para la parte sobrante de registro que solo sera una ves ejm 100%8=4 registros sobrantes a tratar
            {
                 String[] Memoria=new String[(NroRegistros-1)%(FactorBloqueo*Marcos)];
                  AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\Libro.dat") );
                    
                 
                 for(int j = 0;j < Memoria.length; j++)//agregar libros a memoria intermedia
                 {
                     Libro A=Libros.getLibro(L);
                     Memoria[j]=A.Atributos();
                     L=L+1;
                 }
                 AccesoAleatorio.cerrar();
                 BurbujaT(Memoria);//ordenamiento por burbuja
                 Salida.append("\n");
                 Salida.append("ITERACION DE ORDENACION SOT_"+(T+1)+"\n");//titulo de cada archivo de ordenacion para mostrar en la caja de texto
                 for(int k = 0;k < Memoria.length; k++)
                 {
                    Salida.append(Memoria[k]+"\n");
                 }
                 taSalida.setText(Salida.toString());
                 
                 try {
                    AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\SOT_"+(T+1)+".dat") );//creacion de archivo.dat
                    for(int k = 0;k < Memoria.length; k++)
                    {
                        String CodLibro=Memoria[k].substring(0,5);//cortamos cada atributo del registro
                        String Titulo=Memoria[k].substring(5,55);
                        String Autor=Memoria[k].substring(55,85);
                        int Año=Integer.parseInt(Memoria[k].substring(85,89));//conversion a int del año
                        int Estado=Integer.parseInt(Memoria[k].substring(89,90));
                       AccesoAleatorio.añadirLibro(new Libro(CodLibro,Titulo,Autor,Año,Estado));
                    }
                    AccesoAleatorio.cerrar();
      
                } catch (IOException ex) {
                    JOptionPane.showMessageDialog(this, "Error en insercion de datos a registros.", "Error", JOptionPane.ERROR_MESSAGE);
                }
                T=T+1;
            }
            String[] Mem=new String[NroRegistros];
            Men=LimitarCaracter.Parametros(Mem);
            //Libros.cerrar();
            JOptionPane.showMessageDialog(this, "El registro se realizó correctamente.", "Notificación", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, "Error en la escritura de datos.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        //FINAL PRIMERA ETAPA ORDENACION
        //SEGUNDA ETAPA ORDENACION SI N<=M
        try {
            AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\Libro.dat"));
            NroRegistros = AccesoAleatorio.getNumeroRegistros();
            AccesoAleatorio.cerrar();
            String[] MemoriaI=new String[FactorBloqueo*T];//T=N
            Salida.append("\n");
        Salida.append("SMT_FINAL\n");
        int mem=0;
        for(int i = 0;i < T; i++)//4//llenado inicial de datos a la memoriaI 
        {
            
            try {
            AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\SOT_"+(i+1)+".dat") );
            for(int j = 0;j < FactorBloqueo; j++)//3
            {   
                Libro A=AccesoAleatorio.getLibro(j);
                MemoriaI[mem]=A.Atributos();
                //Salida.append(A.Atributos()+"gaaaaaa \n");   
                mem=mem+1;
            }
             AccesoAleatorio.cerrar();
            } catch (IOException ex) {
              JOptionPane.showMessageDialog(this, "Error en insercion de datos a registros.", "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
       
        
        
        
     
        boolean Indice[] =new boolean[FactorBloqueo*T];//arreglo de indices para marcado
        for(int i = 0;i < Indice.length; i++)//inicializacion en falsos
        {
            Indice[i]=false;
        }
        int Acumuladores[] =new int[T];//guardan valores de inicio dinamoco de los valores donde comenzaran las lecturas de cada registro
        for(int i = 0;i < Acumuladores.length; i++)
        {
            Acumuladores[i]=FactorBloqueo;
        }
        int comparador[] =new int[T];//arreglo de indices para marcado el q tenga -1 se debe agregar otros balores
        Salida.append(Men);
        int ContadorRegistros=FactorBloqueo*T;
        while(ContadorRegistros<=NroRegistros-1){
        Actualizar(comparador);
        int pos = Minimo(MemoriaI);//obtengo la posicion de valor minimo 
        AccesoAleatorio.crearFileLibro( new File("ArchivosCreados\\SMT_Final.dat") );//escribir en el archivo el registro
        String CodLibro=MemoriaI[pos].substring(0,5);//cortamos cada atributo del registro
        String Titulo=MemoriaI[pos].substring(5,55);
        String Autor=MemoriaI[pos].substring(55,85);
        int Año=Integer.parseInt(MemoriaI[pos].substring(85,89));//conversion a int del año
        int Estado=Integer.parseInt(MemoriaI[pos].substring(89,90));
        AccesoAleatorio.añadirLibro(new Libro(CodLibro,Titulo,Autor,Año,Estado));
        AccesoAleatorio.cerrar();
        
        MemoriaI[pos]="~~~~~~~~~~~";//cambiamos el valor de ese registro al mayoe posible
        
        CambiarValorTrue(Indice,pos);//cambio el valor de esa posicion a true para decir k esta vacia
        
        ArregloVerdadero(Indice,comparador,FactorBloqueo);//obtengo mi arreglo donde la posicion -1 sera el valor inicial a cambiar y ese valor*factro de bloque el final
         
        if(RegistroACambiar(comparador)==true)
        {
        int H=ObtenerRegistroACambiar(comparador);//verifico si existe algun bloque a cambiar
        AccesoAleatorio.crearFileLibro(new File("ArchivosCreados\\SOT_"+(H+1)+".dat"));//coloco los registros correspandientes en memoriaintermedia
        
        int valor=Acumuladores[H];//valor incial para extraer un registro del alrchivo
        int valor1=H*FactorBloqueo;//posicion de incio para agregar a la memoria intermedia
        for(int k = valor1;k < valor1+FactorBloqueo; k++)//inicializacion en falsos
        {
            
            Libro A=AccesoAleatorio.getLibro(valor);
            MemoriaI[k]=A.Atributos();
            valor=valor+1;
        }                         
        AccesoAleatorio.cerrar();
        Acumuladores[H]=Acumuladores[H]+FactorBloqueo;//actualizo aumentando el valor de inicio de registro del q se saco valores
        }
        
        taSalida.setText(Salida.toString());
        ContadorRegistros=ContadorRegistros+1;
        }
        taSalida.setText(Salida.toString());
        JOptionPane.showMessageDialog(this, "El registro se realizó correctamente.", "Notificación", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException ex) {
            //JOptionPane.showMessageDialog(this, "Error en la escritura de datos.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        //FINAL DEGUNSA ETAPA
        
        //Salida.append("gaaaaa\n");
        
        
        
        
    }//GEN-LAST:event_btnOrdenarTituloActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(OrdenacionMezcla.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(OrdenacionMezcla.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(OrdenacionMezcla.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(OrdenacionMezcla.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new OrdenacionMezcla().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnMezcla;
    private javax.swing.JButton btnOrdenarTitulo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea taSalida;
    private javax.swing.JTextField tbFactorBloqueo;
    private javax.swing.JTextField tbMarcos;
    // End of variables declaration//GEN-END:variables
}
